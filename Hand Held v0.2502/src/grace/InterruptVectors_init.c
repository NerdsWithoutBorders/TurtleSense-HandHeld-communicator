/*
 *  This file is automatically generated and does not require a license
 *
 *  ==== WARNING: CHANGES TO THIS GENERATED FILE WILL BE OVERWRITTEN ====
 *
 *  To make changes to the generated code, use the space between existing
 *      "USER CODE START (section: <name>)"
 *  and
 *      "USER CODE END (section: <name>)"
 *  comments, where <name> is a single word identifying the section.
 *  Only these sections will be preserved.
 *
 *  Do not move these sections within this file or change the START and
 *  END comments in any way.
 *  ==== ALL OTHER CHANGES WILL BE OVERWRITTEN WHEN IT IS REGENERATED ====
 *
 *  This file was generated from
 *      C:/ti/grace_2_20_02_32/packages/ti/mcu/msp430/csl/interrupt_vectors/InterruptVectors_init.xdt
 */
#include <msp430.h>

/* USER CODE START (section: InterruptVectors_init_c_prologue) */
#define INTERRUPTS_PER_SECOND 16		// number of interrupts each second
#define TAMPER_SECONDS 2				// number of seconds to wait before checking for a tamper

extern volatile int secCount;
extern volatile unsigned char red_count, sensor_ready, testing, tamper_count, button_pushed;
extern volatile unsigned char interruptCount;			// counts clock interrupts every eighth of a second, wakes up every 8 counts
extern volatile unsigned char led[3], led_count[3], led_blinks[3];
extern unsigned char speeds[4];


#define OFF 0  // also very fast
#define FAST 1
#define MEDIUM 2
#define SLOW 3
#define MONITOR_PHONE 4
#define CONSTANT_ON 8
#define ONE_BLINK 16
#define TWO_BLINKS 32
#define THREE_BLINKS 48
#define FOUR_BLINKS 64
#define FIVE_BLINKS 60
#define CASCADE 128
#define FAST_CASCADE 129
#define SLOW_CASCADE 131
#define RED 1
#define YELLOW 2
#define GREEN 4
#define BUTTON 8
#define BUTTON_PUSHED (!(P1IN & BUTTON))
#define PAUSE 4

/* USER CODE END (section: InterruptVectors_init_c_prologue) */

/*
 *  ======== InterruptVectors_graceInit ========
 */
void InterruptVectors_graceInit(void)
{
}

/*
 *  ======== Timer0_B3 Interrupt Service Routine ======== 
 */
#pragma vector=TIMER0_B0_VECTOR
__interrupt void TIMER0_B0_ISR_HOOK(void)
{
    /* USER CODE START (section: TIMER0_B0_ISR_HOOK) */

	// Set LED to turn on, off, or blink

	// bit 0 and bit 1 = speed (fast, medium, slow)
	// bit 2  = monitor phone connection (only for LED2) -- supersedes other settings except cascades
	// bit 3  = constantly on -- supersedes blinking
	// bit 4, bit 5 and bit 6 = number of repetitive blinks (1 to 7)
	//		  zero is continuous blinking.
	// bit 7 = cascade blinking -- supersedes all other settings

	// 0 = off
	// 1 = constant fast blinking
	// 2 = constant medium blinking
	// 3 = constant slow blinking
	// 4 = monitor the phone status
	// 8 = constant on
	// 16 = one blink
	// 32 = two blinks
	// 48 = three blinks
	// 64 = four blinks
	// 80 = five blinks
	// 96 = six blinks
	// 112 = seven blinks
	// 128	= cascade (speed set by lower bits) -- supersedes all other settings
	unsigned char n, bit;

	// cascades
	if ((led[0] | led[1] | led[2]) & CASCADE)
	{	P1OUT &= 0xF8;			// Turn off all of the LEDs
		if (led_count[0])		// if led0 was on
		{	led_count[0]--;		// decrement its count
			if (led_count[0])	// if it should still be on
			{	P1OUT |= 0x01;	// turn it back on
				led_count[1]=0;	// keep the other LED's off
				led_count[2]=0;	// by making their counters zero
			}
			else				// if the counter for led0 just turned zero
			{	led_count[1] = speeds[led[1] & 0x03];	// set speed for led1
				P1OUT |= 0x02;					// turn on led1
			}
		}
		else if (led_count[1])	// if led0 was not on, check led1
		{	led_count[1]--;		// decrement its count if it was on
			if (led_count[1])	// if it should still be on
			{	P1OUT |= 0x02;	// turn it back on
				led_count[2]=0;	// keep the other LEDs off
				led_count[0]=0;
			}
			else				// if the counter for led1 just turned zero
			{	led_count[2] = speeds[led[2] & 0x03];	// set speed for led2
				P1OUT |= 0x04;	// turn on led2
			}
		}
		else if (led_count[2])	// if led0 and led1 were not on, check led2
		{	led_count[2]--;		// decrement its count if it was on
			if (led_count[2])	// if it should still be on
			{	P1OUT |= 0x04;	// turn it back on
				led_count[1]=0;	// keep the other LEDs off
				led_count[0]=0;
			}
			else				// if the counter for led2 just turned zero
			{	led_count[0] = speeds[led[0] & 0x03];	// set speed for led0
				P1OUT |= 0x01;	// turn on led0
			}
		}
		else					// if none of the LEDs were on to begin with
		{	led_count[0] = speeds[led[0] & 0x03];	// set speed for led0
			P1OUT |= 0x01;		// turn on led0
		}

	}
	else						// we only look at the other bits if we are not cascading
	{	bit = 0x01;
		for (n=0; n<3; n++)		// deal with each led separately

		{	// constant on
			if (led[n] & 0x08) P1OUT |= bit;	// turn the led on if it is constant
			// monitor phone
			else if (led[n] & 0x04)
			{	if (P2IN & BIT2) P1OUT |= bit ; // mimic the PHNMON input
				else P1OUT &= ~bit ; // mimic the PHNMON input
			}
			//  blinks
			else if (led[n])
			{	led_count[n]--;						// decrement its timing count
				if (!led_count[n])  				// don't do anything unless the count is zero
				{	led_count[n] = speeds[led[n] & 0x03];	// set the count to the speed bits
					if (led[n] < 4)	P1OUT ^= bit;	// switch the bit on or off if constant blinking
					else							// otherwise we are counting blinks
					{	led_blinks[n]--;			// decrement the blink counter
						if (!led_blinks[n]) 		// if the blink counter is zero
						{	P1OUT &= ~bit;			// switch the bit off
							led_blinks[n] = (led[n]>>3) + PAUSE; // reset the counter for twice the number of blinks plus the pause time
						}
						else if (led_blinks[n] < led[n]>>3) P1OUT ^= bit;	// otherwise if the blink counter is low enough switch the bit on or off
					}
				}
			}
			// off
			else
			{	P1OUT &= ~bit;		//if it is zero, turn off the LED
				led_blinks[n] = 0;	// and reset the counts
				led_count[n] = 0;
			}
			bit<<=1;		// next bit
		}
	}
	if (testing) testing++;							// sensor timout during testing
	if (BUTTON_PUSHED) button_pushed++;
	else button_pushed = 0;
	if (interruptCount++ > INTERRUPTS_PER_SECOND)		// do nothing most of the time
	{ 	interruptCount = 0 ;
		if (tamper_count++ > TAMPER_SECONDS) tamper_count = 0 ;	// Check for a tamper condition every 10 seconds
		__low_power_mode_off_on_exit();				// Every second the main loop starts up again
	}
    /* USER CODE END (section: TIMER0_B0_ISR_HOOK) */
}



/*
 *  ======== PORT1 Interrupt Service Routine ========
 *
 * Here are several important notes on using PORT1 interrupt Handler:
 * 1. User could use the following code to efficiently service the interrupt
 *    handler. Just simply copy and paste it into your user definable code
 *    section.

    switch(__even_in_range(P1IV, P1IV_P1IFG7))
    {
        case P1IV_NONE: break;              // Vector 0: No interrupts pending;
        case P1IV_P1IFG0: break;            // Vector 2: P1IFG.0;
        case P1IV_P1IFG1: break;            // Vector 4: P1IFG.1;
        case P1IV_P1IFG2: break;            // Vector 6: P1IFG.2;
        case P1IV_P1IFG3: break;            // Vector 8: P1IFG.3;
        case P1IV_P1IFG4: break;            // Vector 10: P1IFG.4;
        case P1IV_P1IFG5: break;            // Vector 12: P1IFG.5;
        case P1IV_P1IFG6: break;            // Vector 14: P1IFG.6;
        case P1IV_P1IFG7: break;            // Vector 16: P1IFG.7;
        default: break;
    }

 * 2. User could also exit from low power mode and continue with main
 *    program execution by using the following instruction before exiting
 *    this interrupt handler.
 *
 *    __bic_SR_register_on_exit(LPMx_bits);
 *
 */
#pragma vector=PORT1_VECTOR
__interrupt void PORT1_ISR_HOOK(void)
{

    /* USER CODE START (section: PORT1_ISR_HOOK) */
    /* replace this comment with your code */
    /* USER CODE END (section: PORT1_ISR_HOOK) */
}
/*
 * ======== Preserved user code snippets ========
 */
#if 0
/* USER CODE START (section: ADC10_ISR_HOOK) */
    /* replace this comment with your code */
    /* USER CODE END (section: ADC10_ISR_HOOK) */
#endif
